# -*- coding: utf-8 -*-
"""Final_Code_SARIMA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IKXD6e33K4coLbnZyjqjJCkZiHmRQ_ap

NDWI
"""

import pandas as pd
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np
import matplotlib.pyplot as plt

# Load the NDWI dataset
ndwi = pd.read_csv('/content/1_NDWI_TimeSeries_Delhi.csv - NDWI_TimeSeries_Delhi.csv.csv')

# Convert the 'date' column to datetime format and set it as the index
ndwi['date'] = pd.to_datetime(ndwi['date'])
ndwi.set_index('date', inplace=True)

# Resample the data to monthly frequency (if it's not already)
ndwi_resampled = ndwi.resample('M').mean()

# Define a list of SARIMA orders to try
sarima_orders = [
    ((1, 1, 1), (1, 1, 1, 12)),  # SARIMA(1,1,1)x(1,1,1,12)
    ((1, 1, 1), (2, 1, 1, 12)),  # SARIMA(1,1,1)x(2,1,1,12)
    ((2, 1, 2), (1, 1, 1, 12)),  # SARIMA(2,1,2)x(1,1,1,12)
    ((2, 1, 2), (2, 1, 2, 12)),  # SARIMA(2,1,2)x(2,1,2,12)
]

# Initialize a list to store the results
results = []

# Define forecast period (2023-2025)
forecast_periods = 24  # 24 months to forecast

# Loop over the SARIMA orders and fit the models
for order, seasonal_order in sarima_orders:
    model = SARIMAX(ndwi_resampled, order=order, seasonal_order=seasonal_order)
    model_fit = model.fit(disp=False)

    # Calculate evaluation metrics
    predicted_values = model_fit.fittedvalues
    mse = mean_squared_error(ndwi_resampled.iloc[1:], predicted_values[1:])
    rmse = np.sqrt(mse)
    mae = mean_absolute_error(ndwi_resampled.iloc[1:], predicted_values[1:])
    aic = model_fit.aic
    bic = model_fit.bic

    # Forecast future values
    forecast = model_fit.get_forecast(steps=forecast_periods)
    forecast_index = pd.date_range(start=ndwi_resampled.index[-1] + pd.DateOffset(months=1),
                                   periods=forecast_periods,
                                   freq='M')
    forecast_values = forecast.predicted_mean
    forecast_conf_int = forecast.conf_int()

    # Store the results in a dictionary
    results.append({
        'Order': order,
        'Seasonal_Order': seasonal_order,
        'MSE': mse,
        'RMSE': rmse,
        'MAE': mae,
        'AIC': aic,
        'BIC': bic,
        'Forecast_Index': forecast_index,
        'Forecast_Values': forecast_values,
        'Forecast_Conf_Int': forecast_conf_int
    })

    # Plot the historical data and forecast
    plt.figure(figsize=(12, 6))
    plt.plot(ndwi_resampled, label='Historical NDWI Data')
    plt.plot(pd.Series(forecast_values, index=forecast_index), color='red', label='Forecasted NDWI')
    plt.fill_between(forecast_index,
                     forecast_conf_int.iloc[:, 0],
                     forecast_conf_int.iloc[:, 1],
                     color='red',
                     alpha=0.3)
    plt.title(f'SARIMA{order}x{seasonal_order} NDWI Forecast (2023-2025)')
    plt.xlabel('Date')
    plt.ylabel('NDWI')
    plt.legend()
    plt.show()

# Convert the results to a DataFrame
results_df = pd.DataFrame(results)

# Display the results
print(results_df)

"""Turbidity"""

import pandas as pd
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np
import matplotlib.pyplot as plt

# Load the Turbidity dataset
turbidity = pd.read_csv('/content/6Turbidity_TimeSeries_Delhi - Turbidity_TimeSeries_Delhi.csv')

# Convert the 'date' column to datetime format and set it as the index
turbidity['date'] = pd.to_datetime(turbidity['date'])
turbidity.set_index('date', inplace=True)

# Resample the data to monthly frequency (if it's not already)
turbidity_resampled = turbidity.resample('M').mean()

# Define a list of SARIMA orders to try
sarima_orders = [
    ((1, 1, 1), (1, 1, 1, 12)),  # SARIMA(1,1,1)x(1,1,1,12)
    ((1, 1, 1), (2, 1, 1, 12)),  # SARIMA(1,1,1)x(2,1,1,12)
    ((2, 1, 2), (1, 1, 1, 12)),  # SARIMA(2,1,2)x(1,1,1,12)
    ((2, 1, 2), (2, 1, 2, 12)),  # SARIMA(2,1,2)x(2,1,2,12)
]

# Initialize a list to store the results
results = []

# Define forecast period (2023-2025)
forecast_periods = 24  # 24 months to forecast

# Loop over the SARIMA orders and fit the models
for order, seasonal_order in sarima_orders:
    model = SARIMAX(turbidity_resampled, order=order, seasonal_order=seasonal_order)
    model_fit = model.fit(disp=False)

    # Calculate evaluation metrics
    predicted_values = model_fit.fittedvalues
    mse = mean_squared_error(turbidity_resampled.iloc[1:], predicted_values[1:])
    rmse = np.sqrt(mse)
    mae = mean_absolute_error(turbidity_resampled.iloc[1:], predicted_values[1:])
    aic = model_fit.aic
    bic = model_fit.bic

    # Forecast future values
    forecast = model_fit.get_forecast(steps=forecast_periods)
    forecast_index = pd.date_range(start=turbidity_resampled.index[-1] + pd.DateOffset(months=1),
                                   periods=forecast_periods,
                                   freq='M')
    forecast_values = forecast.predicted_mean
    forecast_conf_int = forecast.conf_int()

    # Store the results in a dictionary
    results.append({
        'Order': order,
        'Seasonal_Order': seasonal_order,
        'MSE': mse,
        'RMSE': rmse,
        'MAE': mae,
        'AIC': aic,
        'BIC': bic,
        'Forecast_Index': forecast_index,
        'Forecast_Values': forecast_values,
        'Forecast_Conf_Int': forecast_conf_int
    })

    # Plot the historical data and forecast
    plt.figure(figsize=(12, 6))
    plt.plot(turbidity_resampled, label='Historical Turbidity Data')
    plt.plot(pd.Series(forecast_values, index=forecast_index), color='red', label='Forecasted Turbidity')
    plt.fill_between(forecast_index,
                     forecast_conf_int.iloc[:, 0],
                     forecast_conf_int.iloc[:, 1],
                     color='red',
                     alpha=0.3)
    plt.title(f'SARIMA{order}x{seasonal_order} Turbidity Forecast (2023-2025)')
    plt.xlabel('Date')
    plt.ylabel('Turbidity')
    plt.legend()
    plt.show()

# Convert the results to a DataFrame
results_df = pd.DataFrame(results)

# Display the results
print(results_df)

"""NDVI"""

import pandas as pd
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np
import matplotlib.pyplot as plt

# Load the NDVI dataset
ndvi = pd.read_csv('/content/2NDVI_TimeSeries_Delhi - NDVI_TimeSeries_Delhi.csv')

# Convert the 'date' column to datetime format and set it as the index
ndvi['date'] = pd.to_datetime(ndvi['date'])
ndvi.set_index('date', inplace=True)

# Resample the data to monthly frequency (if it's not already)
ndvi_resampled = ndvi.resample('M').mean()

# Define a list of SARIMA orders to try
sarima_orders = [
    ((1, 1, 1), (1, 1, 1, 12)),  # SARIMA(1,1,1)x(1,1,1,12)
    ((1, 1, 1), (2, 1, 1, 12)),  # SARIMA(1,1,1)x(2,1,1,12)
    ((2, 1, 2), (1, 1, 1, 12)),  # SARIMA(2,1,2)x(1,1,1,12)
    ((2, 1, 2), (2, 1, 2, 12)),  # SARIMA(2,1,2)x(2,1,2,12)
]

# Initialize a list to store the results
results = []

# Define forecast period (2023-2025)
forecast_periods = 24  # 24 months to forecast

# Loop over the SARIMA orders and fit the models
for order, seasonal_order in sarima_orders:
    model = SARIMAX(ndvi_resampled, order=order, seasonal_order=seasonal_order)
    model_fit = model.fit(disp=False)

    # Calculate evaluation metrics
    predicted_values = model_fit.fittedvalues
    mse = mean_squared_error(ndvi_resampled.iloc[1:], predicted_values[1:])
    rmse = np.sqrt(mse)
    mae = mean_absolute_error(ndvi_resampled.iloc[1:], predicted_values[1:])
    aic = model_fit.aic
    bic = model_fit.bic

    # Forecast future values
    forecast = model_fit.get_forecast(steps=forecast_periods)
    forecast_index = pd.date_range(start=ndvi_resampled.index[-1] + pd.DateOffset(months=1),
                                   periods=forecast_periods,
                                   freq='M')
    forecast_values = forecast.predicted_mean
    forecast_conf_int = forecast.conf_int()

    # Store the results in a dictionary
    results.append({
        'Order': order,
        'Seasonal_Order': seasonal_order,
        'MSE': mse,
        'RMSE': rmse,
        'MAE': mae,
        'AIC': aic,
        'BIC': bic,
        'Forecast_Index': forecast_index,
        'Forecast_Values': forecast_values,
        'Forecast_Conf_Int': forecast_conf_int
    })

    # Plot the historical data and forecast
    plt.figure(figsize=(12, 6))
    plt.plot(ndvi_resampled, label='Historical NDVI Data')
    plt.plot(pd.Series(forecast_values, index=forecast_index), color='red', label='Forecasted NDVI')
    plt.fill_between(forecast_index,
                     forecast_conf_int.iloc[:, 0],
                     forecast_conf_int.iloc[:, 1],
                     color='red',
                     alpha=0.3)
    plt.title(f'SARIMA{order}x{seasonal_order} NDVI Forecast (2023-2025)')
    plt.xlabel('Date')
    plt.ylabel('NDVI')
    plt.legend()
    plt.show()

# Convert the results to a DataFrame
results_df = pd.DataFrame(results)

# Display the results
print(results_df)

"""SSC"""

import pandas as pd
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np
import matplotlib.pyplot as plt

# Load the SSC dataset
ssc = pd.read_csv('/content/4SSC_TimeSeries_Delhi - SSC_TimeSeries_Delhi.csv')

# Convert the 'date' column to datetime format and set it as the index
ssc['date'] = pd.to_datetime(ssc['date'])
ssc.set_index('date', inplace=True)

# Resample the data to monthly frequency (if it's not already)
ssc_resampled = ssc.resample('M').mean()

# Define SARIMA orders to try
sarima_orders = [
    ((1, 1, 1), (1, 1, 1, 12)),
    ((1, 1, 1), (2, 1, 1, 12)),
    ((2, 1, 2), (1, 1, 1, 12)),
    ((2, 1, 2), (2, 1, 2, 12))
]

# Initialize a list to store the results
results = []

# Define forecast period (2023-2025)
forecast_periods = 24

# Loop over the SARIMA orders and fit the models
for order, seasonal_order in sarima_orders:
    model = SARIMAX(ssc_resampled, order=order, seasonal_order=seasonal_order)
    model_fit = model.fit(disp=False)

    # Calculate evaluation metrics
    predicted_values = model_fit.fittedvalues
    mse = mean_squared_error(ssc_resampled.iloc[1:], predicted_values[1:])
    rmse = np.sqrt(mse)
    mae = mean_absolute_error(ssc_resampled.iloc[1:], predicted_values[1:])
    aic = model_fit.aic
    bic = model_fit.bic

    # Forecast future values
    forecast = model_fit.get_forecast(steps=forecast_periods)
    forecast_index = pd.date_range(start=ssc_resampled.index[-1] + pd.DateOffset(months=1),
                                   periods=forecast_periods,
                                   freq='M')
    forecast_values = forecast.predicted_mean
    forecast_conf_int = forecast.conf_int()

    # Store the results in a dictionary
    results.append({
        'Order': order,
        'Seasonal_Order': seasonal_order,
        'MSE': mse,
        'RMSE': rmse,
        'MAE': mae,
        'AIC': aic,
        'BIC': bic,
        'Forecast_Index': forecast_index,
        'Forecast_Values': forecast_values,
        'Forecast_Conf_Int': forecast_conf_int
    })

    # Plot the historical data and forecast
    plt.figure(figsize=(12, 6))
    plt.plot(ssc_resampled, label='Historical SSC Data')
    plt.plot(pd.Series(forecast_values, index=forecast_index), color='red', label='Forecasted SSC')
    plt.fill_between(forecast_index,
                     forecast_conf_int.iloc[:, 0],
                     forecast_conf_int.iloc[:, 1],
                     color='red',
                     alpha=0.3)
    plt.title(f'SARIMA{order}x{seasonal_order} SSC Forecast (2023-2025)')
    plt.xlabel('Date')
    plt.ylabel('SSC')
    plt.legend()
    plt.show()

# Convert the results to a DataFrame
results_df = pd.DataFrame(results)

# Display the results
print(results_df)

"""DOM"""

import pandas as pd
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np
import matplotlib.pyplot as plt

# Load the DOM dataset
dom = pd.read_csv('/content/3DOM_TimeSeries_Delhi - DOM_TimeSeries_Delhi.csv')

# Convert the 'date' column to datetime format and set it as the index
dom['date'] = pd.to_datetime(dom['date'])
dom.set_index('date', inplace=True)

# Resample the data to monthly frequency (if it's not already)
dom_resampled = dom.resample('M').mean()

# Define SARIMA orders to try
sarima_orders = [
    ((1, 1, 1), (1, 1, 1, 12)),
    ((1, 1, 1), (2, 1, 1, 12)),
    ((2, 1, 2), (1, 1, 1, 12)),
    ((2, 1, 2), (2, 1, 2, 12))
]

# Initialize a list to store the results
results = []

# Define forecast period (2024-2025)
forecast_periods = 24

# Loop over the SARIMA orders and fit the models
for order, seasonal_order in sarima_orders:
    model = SARIMAX(dom_resampled, order=order, seasonal_order=seasonal_order)
    model_fit = model.fit(disp=False)

    # Calculate evaluation metrics
    predicted_values = model_fit.fittedvalues
    mse = mean_squared_error(dom_resampled.iloc[1:], predicted_values[1:])
    rmse = np.sqrt(mse)
    mae = mean_absolute_error(dom_resampled.iloc[1:], predicted_values[1:])
    aic = model_fit.aic
    bic = model_fit.bic

    # Forecast future values
    forecast = model_fit.get_forecast(steps=forecast_periods)
    forecast_index = pd.date_range(start=dom_resampled.index[-1] + pd.DateOffset(months=1),
                                   periods=forecast_periods,
                                   freq='M')
    forecast_values = forecast.predicted_mean
    forecast_conf_int = forecast.conf_int()

    # Store the results in a dictionary
    results.append({
        'Order': order,
        'Seasonal_Order': seasonal_order,
        'MSE': mse,
        'RMSE': rmse,
        'MAE': mae,
        'AIC': aic,
        'BIC': bic,
        'Forecast_Index': forecast_index,
        'Forecast_Values': forecast_values,
        'Forecast_Conf_Int': forecast_conf_int
    })

    # Plot the historical data and forecast
    plt.figure(figsize=(12, 6))
    plt.plot(dom_resampled, label='Historical DOM Data')
    plt.plot(pd.Series(forecast_values, index=forecast_index), color='red', label='Forecasted DOM')
    plt.fill_between(forecast_index,
                     forecast_conf_int.iloc[:, 0],
                     forecast_conf_int.iloc[:, 1],
                     color='red',
                     alpha=0.3)
    plt.title(f'SARIMA{order}x{seasonal_order} DOM Forecast (2024-2025)')
    plt.xlabel('Date')
    plt.ylabel('DOM')
    plt.legend()
    plt.show()

# Convert the results to a DataFrame
results_df = pd.DataFrame(results)

# Display the results
print(results_df)

"""Chlorophyll-a"""

import pandas as pd
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np
import matplotlib.pyplot as plt

# Load the Chlorophyll-a dataset
chlorophyll_a = pd.read_csv('/content/5ChlorophyllA_TimeSeries_Delhi - ChlorophyllA_TimeSeries_Delhi.csv')

# Convert 'date' column to datetime format and set it as index
chlorophyll_a['date'] = pd.to_datetime(chlorophyll_a['date'])
chlorophyll_a.set_index('date', inplace=True)

# Resample to monthly frequency
chlorophyll_a_resampled = chlorophyll_a.resample('M').mean()

# Define SARIMA orders to try
sarima_orders = [
    ((1, 1, 1), (1, 1, 1, 12)),
    ((1, 1, 1), (2, 1, 1, 12)),
    ((2, 1, 2), (1, 1, 1, 12)),
    ((2, 1, 2), (2, 1, 2, 12))
]

# Initialize list to store results
results = []

# Forecast period
forecast_periods = 24

# Loop over SARIMA orders and fit models
for order, seasonal_order in sarima_orders:
    model = SARIMAX(chlorophyll_a_resampled, order=order, seasonal_order=seasonal_order)
    model_fit = model.fit(disp=False)

    # Calculate evaluation metrics
    predicted_values = model_fit.fittedvalues
    mse = mean_squared_error(chlorophyll_a_resampled.iloc[1:], predicted_values[1:])
    rmse = np.sqrt(mse)
    mae = mean_absolute_error(chlorophyll_a_resampled.iloc[1:], predicted_values[1:])
    aic = model_fit.aic
    bic = model_fit.bic

    # Forecast future values
    forecast = model_fit.get_forecast(steps=forecast_periods)
    forecast_index = pd.date_range(start=chlorophyll_a_resampled.index[-1] + pd.DateOffset(months=1),
                                   periods=forecast_periods,
                                   freq='M')
    forecast_values = forecast.predicted_mean
    forecast_conf_int = forecast.conf_int()

    # Store results
    results.append({
        'Order': order,
        'Seasonal_Order': seasonal_order,
        'MSE': mse,
        'RMSE': rmse,
        'MAE': mae,
        'AIC': aic,
        'BIC': bic,
        'Forecast_Index': forecast_index,
        'Forecast_Values': forecast_values,
        'Forecast_Conf_Int': forecast_conf_int
    })

    # Plot the historical data and forecast
    plt.figure(figsize=(12, 6))
    plt.plot(chlorophyll_a_resampled, label='Historical Chlorophyll-a Data')
    plt.plot(pd.Series(forecast_values, index=forecast_index), color='red', label='Forecasted Chlorophyll-a')
    plt.fill_between(forecast_index,
                     forecast_conf_int.iloc[:, 0],
                     forecast_conf_int.iloc[:, 1],
                     color='red',
                     alpha=0.3)
    plt.title(f'SARIMA{order}x{seasonal_order} Chlorophyll-a Forecast (2023-2025)')
    plt.xlabel('Date')
    plt.ylabel('Chlorophyll-a')
    plt.legend()
    plt.show()

# Convert results to DataFrame
results_df = pd.DataFrame(results)

# Display the results
print(results_df)

